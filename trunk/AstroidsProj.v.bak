module AstroidsProj(
//	Clock Input
  input CLOCK_50,	//	50 MHz
  input CLOCK_27,     //      27 MHz
//	Push Button
  input [3:0] KEY,      //	Pushbutton[3:0]
//	DPDT Switch
  input [17:0] SW,		//	Toggle Switch[17:0]
//	7-SEG Display
  output [6:0]	HEX0,HEX1,HEX2,HEX3,HEX4,HEX5,HEX6,HEX7,  // Seven Segment Digits
//	LED
  output [8:0]	LEDG,  //	LED Green[8:0]
  output [17:0] LEDR,  //	LED Red[17:0]
//	GPIO
 inout [35:0] GPIO_0,GPIO_1,	//	GPIO Connections
//	TV Decoder
//TD_DATA,    	//	TV Decoder Data bus 8 bits
//TD_HS,		//	TV Decoder H_SYNC
//TD_VS,		//	TV Decoder V_SYNC
  output TD_RESET,	//	TV Decoder Reset
// VGA
  output VGA_CLK,   						//	VGA Clock
  output VGA_HS,							//	VGA H_SYNC
  output VGA_VS,							//	VGA V_SYNC
  output VGA_BLANK,						//	VGA BLANK
  output VGA_SYNC,						//	VGA SYNC
  output [9:0] VGA_R,   						//	VGA Red[9:0]
  output [9:0] VGA_G,	 						//	VGA Green[9:0]
  output [9:0] VGA_B   						//	VGA Blue[9:0]
);

//	All inout port turn to tri-state
assign	GPIO_0		=	36'hzzzzzzzzz;
assign	GPIO_1		=	36'hzzzzzzzzz;


// reset delay gives some time for peripherals to initialize
wire DLY_RST;
Reset_Delay r0(	.iCLK(CLOCK_50),.oRESET(DLY_RST) );

// Send switches to red leds 
assign LEDR = SW;

// Turn off green leds
assign LEDG = 8'h00;

wire [6:0] blank = 7'b111_1111;

// blank unused 7-segment digits
assign HEX0 = blank;
assign HEX1 = blank;
assign HEX2 = blank;
assign HEX3 = blank;
assign HEX4 = blank;
assign HEX5 = blank;
assign HEX6 = blank;
assign HEX7 = blank;

wire		VGA_CTRL_CLK;
wire		AUD_CTRL_CLK;
wire [9:0]	mVGA_R;
wire [9:0]	mVGA_G;
wire [9:0]	mVGA_B;
wire [9:0]	mCoord_X;
wire [9:0]	mCoord_Y;

assign	TD_RESET = 1'b1; // Enable 27 MHz

VGA_Audio_PLL 	p1 (	
	.areset(~DLY_RST),
	.inclk0(CLOCK_27),
	.c0(VGA_CTRL_CLK),
	.c1(AUD_CTRL_CLK),
	.c2(VGA_CLK)
);

//
wire [9:0]shipX;
wire [15:0]BW;

wire sample_clk;
clk_60hz (CLOCK_27,sample_clk);

reg [14:0]reset = 14'b0;

Spaceship c1(
	.x(mCoord_X),
	.y(mCoord_Y),
	.BW(BW[0]),
	.reset(reset[0]),
	.shipX2(shipX),
	.clk_60hz(sample_clk),
	.left(~KEY[3]),
	.right(~KEY[2])
);

Bullet_Man Bm1(
	.x(mCoord_X),
	.y(mCoord_Y),
	.BW(BW[4:1]),
	.clk_60hz(sample_clk),
	.shootUp(~KEY[1]),
	.shootDown(~KEY[0]),
	.shipx(shipX),
	.reset(reset[4:1])
);


/*
SpaceshipV_05 c1(
	.x(mCoord_X),
	.y(mCoord_Y),
	.red(mVGA_R),
	.green(mVGA_G),
	.blue(mVGA_B),
	.clk(CLOCK_27),
	.left(~KEY[3]),
	.right(~KEY[2])
);*/



Rocks_Man(
.px(mCoord_X),
.py(mCoord_Y),
.clk60hz(sample_clk),
.reset(reset[14:5]),
.pixel(BW[14:5])
);

wire pixel;
assign pixel = |BW;

assign mVGA_R = (pixel? 10'h3ff : 10'h000);
assign mVGA_G = (pixel? 10'h3ff : 10'h000);
assign mVGA_B = (pixel? 10'h3ff : 10'h000);

vga_sync u1(
   .iCLK(VGA_CTRL_CLK),
   .iRST_N(DLY_RST&1'b0),	
   .iRed(mVGA_R),
   .iGreen(mVGA_G),
   .iBlue(mVGA_B),
   // pixel coordinates
   .px(mCoord_X),
   .py(mCoord_Y),
   // VGA Side
   .VGA_R(VGA_R),
   .VGA_G(VGA_G),
   .VGA_B(VGA_B),
   .VGA_H_SYNC(VGA_HS),
   .VGA_V_SYNC(VGA_VS),
   .VGA_SYNC(VGA_SYNC),
   .VGA_BLANK(VGA_BLANK)
);


endmodule




module Bullet_Man(
input [9:0] x,
input [9:0] y,
input clk_60hz,

input [9:0]shipx,
input shootUp,
input shootDown,
input [3:0]reset,

output [3:0]BW
);

reg [3:0]direction;
reg [3:0]start_bullet;
wire fire_delay;
wire [3:0] inUse;

Bullet B0(
	.x(x),
	.y(y),
	.clk_60hz(clk_60hz),
	.direction(direction[0]),
	.start_bullet(start_bullet[0]),
	.reset(reset[0]),
	.BW(BW[0]),
	.inUse(inUse[0]),
	.shipX(shipX)
);
Bullet B1(
	.x(x),
	.y(y),
	.clk_60hz(clk_60hz),
	.direction(direction[1]),
	.start_bullet(start_bullet[1]),
	.reset(reset[1]),
	.BW(BW[1]),
	.inUse(inUse[1]),
	.shipX(shipX)
);
Bullet B2(
	.x(x),
	.y(y),
	.clk_60hz(clk_60hz),
	.direction(direction[2]),
	.start_bullet(start_bullet[2]),
	.reset(reset[2]),
	.BW(BW[2]),
	.inUse(inUse[2]),
	.shipX(shipX)
);
Bullet B3(
	.x(x),
	.y(y),
	.clk_60hz(clk_60hz),
	.direction(direction[3]),
	.start_bullet(start_bullet[3]),
	.reset(reset[3]),
	.BW(BW[3]),
	.inUse(inUse[3]),
	.shipX(shipX)
);


/*
clk_5seconds(
	clk_60hz,
	clk_5seconds,
	ready,
	start);
*/
wire shoot = (shootUp || shootDown);
always @(posedge shoot) begin
	direction= {shootUp,shootUp,shootUp,shootUp};
	if(~inUse[0]) begin
		start_bullet=4'b0001;
		//start=1;
		end
	else if(~inUse[1])begin
		start_bullet=4'b0010;end
		//start=1;
	else if(~inUse[2]) begin
		start_bullet=4'b0100;end
		//start=1;
	else if(~inUse[3]) begin
		start_bullet=4'b1000;end
		//start=1;
	else 
		start_bullet=4'b0;
	
end


endmodule







module Bullet(
input [9:0] x,
input [9:0] y,
input clk_60hz,

input direction,
input start_bullet,
input reset,
input [9:0]shipX,

output BW,
output inUse
); 


assign BW = ((x-1)<bulletX && (x+1)>bulletX && (y-1)<bulletY&&(y+1)>bulletY);

assign inUse= inUse1;

reg inUse1=0;
reg[9:0] bulletX,bulletY;
reg bullet_direction;

always @(clk_60hz) begin
	if (reset||
		inUse1 && direction && (bulletY> 9'd480)||
		inUse1 && ~direction && (bulletY> 9'd0)) begin
			inUse1 = 1'b0;
			bulletX = 9'd800;		
			bulletY = 9'd500;		
		end
	else if (start_bullet&& ~inUse1)begin
		inUse1 = 1'b1;
		bulletX = shipX;
		bulletY = 9'd240;
		bullet_direction = direction;
		end
	else if(bullet_direction)
		bulletY=bulletY+2;
	else
		bulletY=bulletY-2;
	
end
	
endmodule








module Spaceship(
input [9:0] x,
input [9:0] y,
input clk_60hz, 

input left, 
input right,
input reset,

output reg BW,
output [9:0]shipX2);



/* Display generator */


reg [9:0] shipX = 10'd320;
reg [9:0] shipY = 10'd240;



assign shipX2 = shipX;

always @(posedge clk_60hz) begin
	if(reset)begin
		shipX <= 10'd320;
		shipY <= 10'd240;
	end
	
	
	if(left && (shipX<12))
		shipX <= shipX-2;
	else if(right&& (shipX>628))
		shipX <= shipX+2;
end


always @(x)

begin

	if((x-10)<shipX && (x+10)>shipX&&(y-10)<shipY&& (y+10)>shipY )

		BW=1'b1;

	else if((x-1)<shipX && (x+1)>shipX&&(y-12)<shipY&& (y+12)>shipY )

		BW=1'b1;

	else BW=1'b0;

end



endmodule





module fib_16bit (Clk, Q);
	 input Clk;
	 output Q;
	 
	 reg [15:0]SEED = 16'b0010000100100001;
	 
	 always @(posedge Clk) begin
	  SEED<={SEED[14:0],SEED[10]^ (SEED[12]^  (SEED[13]^SEED[15])  ) };
	 end
	 
	 assign Q=SEED;
endmodule

/* Generates a random direction based on a 16 bit random input */
module randomDir(in, out);
	input [15:0] in;
	output [2:0] out;

	//NOTE: generates x01 half the time
	assign out[0] = ~in[1] | in[0];
	assign out[1] = in[1];
	assign out[2] = in[2];
endmodule

/* 2 second rocket generator */
module Clk2sec( input clk60hz, output reg q);
	reg [6:0] counter=7'b0000000;
	always @ (posedge clk60hz) begin
		counter <= counter + 1;
		
		if (counter == 120) begin
			q <= 1;
			counter <=0;
		end
		else q <= 0;
		
	end
endmodule

module Rocks_Man(
input [9:0] px,
input [9:0] py,
input clk60hz,

// reset signal from collision detector
input [9:0] reset,
output [9:0] pixel
);

	wire [9:0] rocks_in_use;
	
	/* Random number generator */
	wire [15:0] randomX;
	wire [15:0] randomY;
	fib_16bit(clk60hz, randomX);
	fib_16bit(clk60hz, randomY);
	
	/* Random direction generator */
	wire [2:0] ranDirX;
	wire [2:0] ranDirY;
	randomDir(randomX, ranDirX);
	randomDir(randomY, ranDirY);
	
	/* Random rocket firing */
	wire spawn;
	reg [9:0] fire;
	Clk2sec(clk60hz, spawn);
	
	always @ (posedge spawn) begin
		//reset fire before firing again
		fire = 0;
		
		if (rocks_in_use[0] == 1'b0)
			fire[0] = 1'b1;
		else if (rocks_in_use[1] == 1'b0)
			fire[1] = 1'b1;
		else if (rocks_in_use[2] == 1'b0)
			fire[2] = 1'b1;
		else if (rocks_in_use[3] == 1'b0)
			fire[3] = 1'b1;
		else if (rocks_in_use[4] == 1'b0)
			fire[4] = 1'b1;
		else if (rocks_in_use[5] == 1'b0)
			fire[5] = 1'b1;
		else if (rocks_in_use[6] == 1'b0)
			fire[6] = 1'b1;
		else if (rocks_in_use[7] == 1'b0)
			fire[7] = 1'b1;
		else if (rocks_in_use[8] == 1'b0)
			fire[8] = 1'b1;
		else if (rocks_in_use[9] == 1'b0)
			fire[9] = 1'b1;			
	
	end
	
	/* Rock 0 */
	Rocks(
	//inputs
	.px(px),
	.py(py),
	.initialX(randomX[9:0]),
	.initialY(randomY[9:0]),
	.dirX(ranDirX),
	.dirY(ranDirY),
	.start(fire[0]),
	.reset(reset[0]),
	.clk60hz(clk60hz),
	//outputs
	.pixel(pixel[0]),
	.inUse(rocks_in_use[0]));
	
	/* Rock 1 */
	Rocks(
	//inputs
	.px(px),
	.py(py),
	.initialX(randomX[9:0]),
	.initialY(randomY[9:0]),
	.dirX(ranDirX),
	.dirY(ranDirY),
	.start(fire[1]),
	.reset(reset[1]),
	.clk60hz(clk60hz),
	//outputs
	.pixel(pixel[1]),
	.inUse(rocks_in_use[1]));


endmodule


module Rocks(
input [9:0] px,
input [9:0] py,

// Initial position of the astroid
input [9:0] initialX,
input [9:0] initialY,

// Direction of travel
input [2:0] dirX,
input [2:0] dirY,

// Set to high to activate the astroid module
input start,

// Set to high to remove astroid from screen and deactivate
input reset,

// This clock is used for calculating next positin of the astroid(rock)
input clk60hz,

// Output pixel signal
output reg pixel,

// Output is high when this astroid is active
output reg inUse);

//initial_x and initial_y should be chosen randomly by a fibonnaci random number generator

/* Registers */
// Rock's position on the screen
reg [9:0] rockX;
reg [9:0] rockY;

always @ (posedge clk60hz) begin
	// Initialization
	if ( start == 1'b1 ) begin
		inUse <= 1'b1;
		rockX <= initialX;
		rockY <= initialY;
	end else if ( reset == 1'b1 ) begin
		inUse <= 1'b0;
	end

	// Movement
	if ( inUse == 1'b1 ) begin
		if (dirX[2] == 1'b0) begin
				rockX <= rockX + dirX[1:0];
		end else begin
				rockX <= rockX - dirX[1:0];
		end
		
		if (dirY[2] == 1'b0) begin
			rockY <= rockY + dirY[1:0];
		end else begin
			rockY <= rockY - dirY[1:0];
		end
	end
end


/* Display generator */
always @(px)
begin
	if((px-12)<rockX && (px+12)>rockX && (py-10)<rockY&& (py+10)>rockY )
		pixel=1'b1;
	else if((px-10)<rockX && (px+10)>rockX && (py-12)<rockY&& (py+12)>rockY )
		pixel=1'b1;
	else pixel=1'b0;
		
end

endmodule
module	Reset_Delay(iCLK,oRESET);
input		iCLK;
output reg	oRESET;
reg	[19:0]	Cont;

always@(posedge iCLK)
begin
	if(Cont!=20'hFFFFF)
	begin
		Cont	<=	Cont+1'b1;
		oRESET	<=	1'b0;
	end
	else
	oRESET	<=	1'b1;
end

endmodule

module clk_60hz (input clk, output reg q);

reg [18:0] counter=19'b0000000000000000000;
	always @ (posedge clk) begin
		counter <= counter + 1;
		
		if (counter == 450000) begin
			q <= 1;
			counter <=0;
		end
		else q <= 0;
		
	end
		

endmodule


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

module vga_sync(
   input iCLK, // 25 MHz clock
   input iRST_N,
   input [9:0] iRed,
   input [9:0] iGreen,
   input [9:0] iBlue,
   // pixel coordinates
   output [9:0] px,
   output [9:0] py,
   // VGA Side
   output  [9:0] VGA_R,
   output  [9:0] VGA_G,
   output  [9:0] VGA_B,
   output reg VGA_H_SYNC,
   output reg VGA_V_SYNC,
   output VGA_SYNC,
   output VGA_BLANK
);

assign	VGA_BLANK	=	VGA_H_SYNC & VGA_V_SYNC;
assign	VGA_SYNC	=	1'b0;

reg [9:0] h_count, v_count;
assign px = h_count;
assign py = v_count;


// Horizontal sync

/* Generate Horizontal and Vertical Timing Signals for Video Signal
* h_count counts pixels (640 + extra time for sync signals)
* 
*  horiz_sync  ------------------------------------__________--------
*  h_count       0                640             659       755    799
*/
parameter H_SYNC_TOTAL = 800;
parameter H_PIXELS =     640;
parameter H_SYNC_START = 659;
parameter H_SYNC_WIDTH =  96;

always@(posedge iCLK or negedge iRST_N)
begin
   if(!iRST_N)
   begin
      h_count <= 10'h000;
      VGA_H_SYNC <= 1'b0;
   end
   else
   begin
      // H_Sync Counter
      if (h_count < H_SYNC_TOTAL-1) h_count <= h_count + 1'b1;
      else h_count <= 10'h0000;

      if (h_count >= H_SYNC_START && 
	h_count < H_SYNC_START+H_SYNC_WIDTH) VGA_H_SYNC = 1'b0;
      else VGA_H_SYNC <= 1'b1;
   end
end
/*  
*  vertical_sync      -----------------------------------------------_______------------
*  v_count             0                                      480    493-494          524
*/
parameter V_SYNC_TOTAL = 525;
parameter V_PIXELS     = 480;
parameter V_SYNC_START = 493;
parameter V_SYNC_WIDTH =   2;
parameter H_START = 699;

always @(posedge iCLK or negedge iRST_N)
begin
   if (!iRST_N)
   begin
      v_count <= 10'h0000;
      VGA_V_SYNC <= 1'b0;
   end
   else if (h_count == H_START)
   begin
      // V_Sync Counter
      if (v_count < V_SYNC_TOTAL-1) v_count <= v_count + 1'b1;
      else v_count <= 10'h0000;

      if (v_count >= V_SYNC_START && 
		v_count < V_SYNC_START+V_SYNC_WIDTH) VGA_V_SYNC = 1'b0;
      else VGA_V_SYNC <= 1'b1;
   end
end
   

// Put all video signals through DFFs to elminate any delays that cause a blurry image

wire video_h_on = (h_count<H_PIXELS);
wire video_v_on = (v_count<V_PIXELS);
wire video_on = video_h_on & video_v_on;

assign VGA_R = (video_on? iRed: 10'h000);
assign VGA_G = (video_on? iGreen: 10'h000);
assign VGA_B = (video_on? iBlue: 10'h000);

/*
always @(posedge iCLK or negedge iRST_N)
	if (!iRST_N)
	begin
		VGA_R <= 10'h000;
		VGA_G <= 10'h000;
		VGA_B <= 10'h000;
	end
	else
	begin
		if (video_on)
		begin
			VGA_R[9:0] <= iRed[9:0];
			VGA_G[9:0] <= iGreen[9:0];
			VGA_B[9:0] <= iBlue[9:0];
		end
		else
		begin
			VGA_R <= 10'h000;
			VGA_G <= 10'h000;
			VGA_B <= 10'h000;
		end
    end
*/
   
endmodule

// megafunction wizard: %ALTPLL%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: altpll 

// ============================================================
// File Name: VGA_Audio_PLL.v
// Megafunction Name(s):
// 			altpll
//
// Simulation Library Files(s):
// 			altera_mf
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// 7.2 Build 175 11/20/2007 SP 1 SJ Web Edition
// ************************************************************


//Copyright (C) 1991-2007 Altera Corporation
//Your use of Altera Corporation's design tools, logic functions 
//and other software and tools, and its AMPP partner logic 
//functions, and any output files from any of the foregoing 
//(including device programming or simulation files), and any 
//associated documentation or information are expressly subject 
//to the terms and conditions of the Altera Program License 
//Subscription Agreement, Altera MegaCore Function License 
//Agreement, or other applicable license agreement, including, 
//without limitation, that your use is for the sole purpose of 
//programming logic devices manufactured by Altera and sold by 
//Altera or its authorized distributors.  Please refer to the 
//applicable agreement for further details.


// synopsys translate_off
`timescale 1 ps / 1 ps
// synopsys translate_on
module VGA_Audio_PLL (
	areset,
	inclk0,
	c0,
	c1,
	c2);

	input	  areset;
	input	  inclk0;
	output	  c0;
	output	  c1;
	output	  c2;

	wire [5:0] sub_wire0;
	wire [0:0] sub_wire6 = 1'h0;
	wire [2:2] sub_wire3 = sub_wire0[2:2];
	wire [1:1] sub_wire2 = sub_wire0[1:1];
	wire [0:0] sub_wire1 = sub_wire0[0:0];
	wire  c0 = sub_wire1;
	wire  c1 = sub_wire2;
	wire  c2 = sub_wire3;
	wire  sub_wire4 = inclk0;
	wire [1:0] sub_wire5 = {sub_wire6, sub_wire4};

	altpll	altpll_component (
				.inclk (sub_wire5),
				.areset (areset),
				.clk (sub_wire0),
				.activeclock (),
				.clkbad (),
				.clkena ({6{1'b1}}),
				.clkloss (),
				.clkswitch (1'b0),
				.configupdate (1'b0),
				.enable0 (),
				.enable1 (),
				.extclk (),
				.extclkena ({4{1'b1}}),
				.fbin (1'b1),
				.fbmimicbidir (),
				.fbout (),
				.locked (),
				.pfdena (1'b1),
				.phasecounterselect ({4{1'b1}}),
				.phasedone (),
				.phasestep (1'b1),
				.phaseupdown (1'b1),
				.pllena (1'b1),
				.scanaclr (1'b0),
				.scanclk (1'b0),
				.scanclkena (1'b1),
				.scandata (1'b0),
				.scandataout (),
				.scandone (),
				.scanread (1'b0),
				.scanwrite (1'b0),
				.sclkout0 (),
				.sclkout1 (),
				.vcooverrange (),
				.vcounderrange ());
	defparam
		altpll_component.clk0_divide_by = 15,
		altpll_component.clk0_duty_cycle = 50,
		altpll_component.clk0_multiply_by = 14,
		altpll_component.clk0_phase_shift = "0",
		altpll_component.clk1_divide_by = 3,
		altpll_component.clk1_duty_cycle = 50,
		altpll_component.clk1_multiply_by = 2,
		altpll_component.clk1_phase_shift = "0",
		altpll_component.clk2_divide_by = 15,
		altpll_component.clk2_duty_cycle = 50,
		altpll_component.clk2_multiply_by = 14,
		altpll_component.clk2_phase_shift = "-9921",
		altpll_component.compensate_clock = "CLK0",
		altpll_component.inclk0_input_frequency = 37037,
		altpll_component.intended_device_family = "Cyclone II",
		altpll_component.lpm_type = "altpll",
		altpll_component.operation_mode = "NORMAL",
		altpll_component.port_activeclock = "PORT_UNUSED",
		altpll_component.port_areset = "PORT_USED",
		altpll_component.port_clkbad0 = "PORT_UNUSED",
		altpll_component.port_clkbad1 = "PORT_UNUSED",
		altpll_component.port_clkloss = "PORT_UNUSED",
		altpll_component.port_clkswitch = "PORT_UNUSED",
		altpll_component.port_configupdate = "PORT_UNUSED",
		altpll_component.port_fbin = "PORT_UNUSED",
		altpll_component.port_inclk0 = "PORT_USED",
		altpll_component.port_inclk1 = "PORT_UNUSED",
		altpll_component.port_locked = "PORT_UNUSED",
		altpll_component.port_pfdena = "PORT_UNUSED",
		altpll_component.port_phasecounterselect = "PORT_UNUSED",
		altpll_component.port_phasedone = "PORT_UNUSED",
		altpll_component.port_phasestep = "PORT_UNUSED",
		altpll_component.port_phaseupdown = "PORT_UNUSED",
		altpll_component.port_pllena = "PORT_UNUSED",
		altpll_component.port_scanaclr = "PORT_UNUSED",
		altpll_component.port_scanclk = "PORT_UNUSED",
		altpll_component.port_scanclkena = "PORT_UNUSED",
		altpll_component.port_scandata = "PORT_UNUSED",
		altpll_component.port_scandataout = "PORT_UNUSED",
		altpll_component.port_scandone = "PORT_UNUSED",
		altpll_component.port_scanread = "PORT_UNUSED",
		altpll_component.port_scanwrite = "PORT_UNUSED",
		altpll_component.port_clk0 = "PORT_USED",
		altpll_component.port_clk1 = "PORT_USED",
		altpll_component.port_clk2 = "PORT_USED",
		altpll_component.port_clk3 = "PORT_UNUSED",
		altpll_component.port_clk4 = "PORT_UNUSED",
		altpll_component.port_clk5 = "PORT_UNUSED",
		altpll_component.port_clkena0 = "PORT_UNUSED",
		altpll_component.port_clkena1 = "PORT_UNUSED",
		altpll_component.port_clkena2 = "PORT_UNUSED",
		altpll_component.port_clkena3 = "PORT_UNUSED",
		altpll_component.port_clkena4 = "PORT_UNUSED",
		altpll_component.port_clkena5 = "PORT_UNUSED",
		altpll_component.port_extclk0 = "PORT_UNUSED",
		altpll_component.port_extclk1 = "PORT_UNUSED",
		altpll_component.port_extclk2 = "PORT_UNUSED",
		altpll_component.port_extclk3 = "PORT_UNUSED";


endmodule


